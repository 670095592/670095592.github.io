<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/10/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><hr><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。也就是说，<strong>代理对象 &#x3D; 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了.</p><h3 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h3><hr><p>某租客Mike要租房，需要和房东签约。但是租房还有很多其它事情,找很多房子，检查房子。但是Mike是第一次租房，对这些具体的事情没什么经验。这时Mike找到中介来做，中介就相当于代理对象，不仅仅按着需求的步骤做了，而且每一步都比Mike做的更好，这就是对被代理对象方法的增强。</p><h3 id="三、静态代理"><a href="#三、静态代理" class="headerlink" title="三、静态代理"></a>三、静态代理</h3><hr><h4 id="1、代码"><a href="#1、代码" class="headerlink" title="1、代码"></a>1、代码</h4><p>​实现步骤：</p><ol><li><p>定义租房接口: IRent，方法:sign(String houseOwner)。</p></li><li><p>定义租客类：Customer，实现接口，和房东完成真实签约。</p></li><li><p>定义中介类：HouseProxy，也实现接口IRent。</p><p>同时引用真实租客类：IRent realCustomer，完成客户签约。<br>另外，实现自己的私有（特有）方法，如：searchHouse和checkHouse。<br>并在接口方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 租房类接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRent</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sign</span><span class="hljs-params">(String houseOwner)</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 租客类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRent</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sign</span><span class="hljs-params">(String houseOwner)</span> &#123;<br>        System.out.println(houseOwner);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中介类（代理）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRent</span>&#123;<br>    <span class="hljs-keyword">private</span> IRent iRent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HouseProxy</span><span class="hljs-params">(IRent iRent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.iRent = iRent;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sign</span><span class="hljs-params">(String houseOwner)</span> &#123;<br>        searchHouse();<br>        System.out.println(houseOwner);<br>        checkHouse();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====查找房子方法====&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====检查房子方法====&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StartProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>        customer.sign(<span class="hljs-string">&quot;=====租客找到了房子=====&quot;</span>);<br><br>        <span class="hljs-type">HouseProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HouseProxy</span>(customer);<br>        proxy.sign(<span class="hljs-string">&quot;=====中介找到了房子=====&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2、缺陷"><a href="#2、缺陷" class="headerlink" title="2、缺陷"></a>2、缺陷</h4><p>​如果一个类需要被代理，就得去创建一个代理类。如果被代理的类过多，这样就需要手动创建很多代理类。为了解决这个问题，便有了动态代理。</p><h3 id="四、动态代理"><a href="#四、动态代理" class="headerlink" title="四、动态代理"></a>四、动态代理</h3><hr><h4 id="1、代码-1"><a href="#1、代码-1" class="headerlink" title="1、代码"></a>1、代码</h4><p>​要实现动态代理，需要解决两个问题：</p><ol><li><p>如何根据加载到内存中的被代理类（租客类），动态创建出代理类（中介）及其对象。</p></li><li><p>当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法。</p><p>解决以上2个问题，</p><p><strong>需要用到Proxy类的静态方法 newProxyInstance</strong>。</p><p><strong>InvocationHandler</strong> 是一个接口，内部只有一个方法invoke</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StartProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>        <span class="hljs-type">IRent</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (IRent) ProxyFactory.getProxyInstance(customer);<br>        <span class="hljs-comment">//代理类对象</span><br>        proxyInstance.sign(<span class="hljs-string">&quot;租房子&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产代理类的工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span>&#123;<br><br>    <span class="hljs-comment">//调用此方法，返回一个代理类的对象。解决问题一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span>&#123;<span class="hljs-comment">//obj被代理类的对象</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()&#123;<br><br>            <span class="hljs-comment">//当我们通过代理类的对象，调用方法a时，就会自动调用如下方法: invoke()</span><br>            <span class="hljs-comment">//将被代理类要执行的方法就声明在invoke()方法中 解决问题二</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> method.invoke(obj, args);<br>                System.out.println(<span class="hljs-string">&quot;代理对象增强方法&quot;</span>);<br>                <span class="hljs-keyword">return</span> invoke;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h4><p>调用代理对象的方法时，<strong>实际上调用的是InvocationHandler的invoke方法</strong>，这个方法内部不仅调用了被代理对象的方法，还可以增加其他功能</p><h3 id="五、基于CGLib的动态代理"><a href="#五、基于CGLib的动态代理" class="headerlink" title="五、基于CGLib的动态代理"></a>五、基于CGLib的动态代理</h3><hr><p>Java动态代理是<strong>面向接口</strong>的代理模式，如果没有接口，但是想要去实现动态代理，就需要用到CGLib来进行动态代理了</p><p>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类。</p><h4 id="1、使用CGLib实现动态代理"><a href="#1、使用CGLib实现动态代理" class="headerlink" title="1、使用CGLib实现动态代理"></a>1、使用CGLib实现动态代理</h4><p><strong>被代理的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====查找房子方法====&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====检查房子方法====&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;====签约房子方法====&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义拦截器实现MethodInterceptor接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LawyerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 前置增强</span><br>        System.out.println(<span class="hljs-string">&quot;中介给出建议&quot;</span>);<br>        <span class="hljs-comment">// 被代理类执行的方法（被增强的方法）</span><br>        <span class="hljs-comment">// 注意这里是调用invokeSuper而不是invoke，否则死循环;</span><br>        <span class="hljs-comment">// methodProxy.invokeSuper执行的是原始类的方法;</span><br>        <span class="hljs-comment">// method.invoke执行的是子类的方法;</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br><br>        <span class="hljs-comment">// 后置增强</span><br>        System.out.println(<span class="hljs-string">&quot;中介帮忙&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> invoke;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用Enhancer创建代理对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建增强器</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br><br>        <span class="hljs-comment">// 传入被代理的Class对象（作为代理对象的父类）</span><br>        enhancer.setSuperclass(Customer.class);<br><br>        <span class="hljs-comment">// 设置回调函数，传入自定义的拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LawyerInterceptor</span>());<br><br>        <span class="hljs-comment">// 获取代理对象</span><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Customer) enhancer.create();<br>        System.out.println(<span class="hljs-string">&quot;租房开始&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------第一步-------&quot;</span>);<br>        proxy.searchHouse();<br><br>        System.out.println(<span class="hljs-string">&quot;-------第二步-------&quot;</span>);<br>        proxy.checkHouse();<br><br>        System.out.println(<span class="hljs-string">&quot;-------第三步-------&quot;</span>);<br>        proxy.sign();<br><br>        System.out.println(<span class="hljs-string">&quot;租房结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、使用CGLib实现动态代理"><a href="#2、使用CGLib实现动态代理" class="headerlink" title="2、使用CGLib实现动态代理"></a>2、使用CGLib实现动态代理</h4><p>CGLib可以为没有实现接口的类创建代理类。其原理是CGLib底层使用了ASM框架，该框架可以通过修改字节码，来创建一个被代理类的子类，也就是代理类。并在子类中采用方法拦截的技术<strong>拦截所有父类方法的调用，顺势织入横切逻辑</strong>。这种思想符合<strong>里氏替换原则</strong>，即子类可以扩展父类的功能，但是不能改变父类原有的功能。</p><h4 id="代理类的父类"><a href="#代理类的父类" class="headerlink" title="代理类的父类"></a>代理类的父类</h4><p>就上面的例子，我们通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">proxy.getClass().getSuperclass();<br></code></pre></td></tr></table></figure><p>来获取代理类的父类，可以看到其父类是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.hhh.study.Customer<br></code></pre></td></tr></table></figure><p>也就是我们的被代理类，这也从一定程度上说明自定义拦截器在调用被拦截对象的方法时，需要调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/25/hello-world/"/>
    <url>/2022/10/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
